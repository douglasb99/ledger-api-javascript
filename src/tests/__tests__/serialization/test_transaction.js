import {Transaction} from "../../../fetchai/ledger";
import {Entity} from "../../../fetchai/ledger/crypto/entity";
import * as address from "../../../fetchai/ledger/serialization/address";
import {decode_transaction} from "../../../fetchai/ledger/serialization/transaction.js";


const _PRIVATE_KEYS = [
    '1411d53f88e736eac7872430dbe5b55ac28c17a3e648c388e0bd1b161ab04427',
    '3436c184890d498b25bc2b5cb0afb6bad67379ebd778eae1de40b6e0f0763825',
    '4a56a19355f934174f6388b3c80598abb151af79c23d5a7af45a13357fb71253',
    'f9d67ec139eb7a1cb1f627357995847392035c1e633e8530de5ab5d04c6e9c33',
    '80f0e1c69e5f1216f32647c20d744c358e0894ebc855998159017a5acda208ba'
];

const ENTITIES = () => {
    PRIVATE_KEYS.map(key => Entity.from_hex(key));

}

const IDENTITIES = () => {
    PRIVATE_KEYS.map(key => new Identity.from_hex(key));
}


const _calculate_integer_stream_size = (len) => {
    if (len < 0x80) {
        return 1;
    } else if (len < 0x100) {
        return 2;
    } else if (len < 0x1000) {
        return 4;
    } else {
        return 8;
    }
}


describe(':Transaction', () => {

    const EXPECTED_SIGNATURE_BYTE_LEN = 64;
    const EXPECTED_SIGNATURE_LENGTH_FIELD_LEN = this._calculate_integer_stream_size(EXPECTED_SIGNATURE_BYTE_LEN);
    const EXPECTED_SERIAL_SIGNATURE_LENGTH = EXPECTED_SIGNATURE_BYTE_LEN + EXPECTED_SIGNATURE_LENGTH_FIELD_LEN;

    // switch to before all at the end after development
    beforeEach(() => {
  this.ENTITIES();
  this.IDENTITIES();
});


     test('test simple decode', () => {
        const EXPECTED_PAYLOAD = "a12400532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d44235130ac5aab442e39f9aa27118956695229212dd2f1ab5b714e9f6bd581511c101000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c";

        decode_transaction


     }

    test('test simple transfer', () => {

        //
        // const EXPECTED_PAYLOAD = "a12400532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d44235130ac5aab442e39f9aa27118956695229212dd2f1ab5b714e9f6bd581511c101000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c";
        // // build the payload bytes for the transaction
        // const payload = new Transaction();
        // payload.from_address = IDENTITIES[0];
        // payload.add_transfer(IDENTITIES[1], 256);
        // payload.add_signer(IDENTITIES[0]);
        //
        //
        // const ref_address = _dummy_address()
        // const buf = Buffer.from('')
        // const encoded = address.encode(buf, ref_address)
        // const expected = ref_address.toBytes()
        // expect(Buffer.byteLength(expected)).toBe(Buffer.byteLength(encoded))
        // expect(expected.toString('hex')).toBe(encoded.toString('hex'))
    })


    /**
     *
     *  def test_simple_transfer(self):
        EXPECTED_PAYLOAD = "a12400532398dd883d1990f7dad3fde6a53a53347afc2680a04748f7f15ad03cadc4d44235130ac5aab442e39f9aa27118956695229212dd2f1ab5b714e9f6bd581511c101000000000418c2a33af8bd2cba7fa714a840a308a217aa4483880b1ef14b4fdffe08ab956e3f4b921cec33be7c258cfd7025a2b9a942770e5b17758bcc4961bbdc75a0251c"

        # build the payload bytes for the transaction
        payload = Transaction()
        payload.from_address = IDENTITIES[0]
        payload.add_transfer(IDENTITIES[1], 256)
        payload.add_signer(IDENTITIES[0])

        # sign the final transaction
        transaction_bytes = encode_transaction(payload, [ENTITIES[0]])

        self.assertIsExpectedTx(payload, transaction_bytes, EXPECTED_PAYLOAD)

        # attempt to decode a transaction from the generated bytes
        buffer = io.BytesIO(transaction_bytes)
        success, tx = decode_transaction(buffer)

        self.assertTrue(success)
        self.assertTxAreEqual(payload, tx)
     *
     *
     */

});



//
// function assertIsExpectedTx(payload, transaction_bytes, expected_hex_payload){
//     // a payload needs at least one signee
//     //	const num_signatures = Object.keys(payload._signers).length
//     // expect(num_signatures).toBeGreaterThan(0);
//
//     // signatures_serial_length = EXPECTED_SERIAL_SIGNATURE_LENGTH * len(payload.signers);
// }


/* def assertIsExpectedTx(self, payload: Transaction, transaction_bytes: bytes, expected_hex_payload: str):
        # a payload needs at least one signee
        self.assertGreater(len(payload.signers), 0)

        # calculate the serial length of the signatures (so that we can extract the payload)
        signatures_serial_length = self.EXPECTED_SERIAL_SIGNATURE_LENGTH * len(payload.signers)

        # sanity check
        self.assertGreater(len(transaction_bytes), signatures_serial_length)

        expected_payload_end = len(transaction_bytes) - signatures_serial_length

        # extract and verify the payload
        payload_bytes = transaction_bytes[:expected_payload_end]
        self.assertEqual(expected_hex_payload, binascii.hexlify(payload_bytes).decode())

        # loop through and verify all the signatures
        buffer = io.BytesIO(transaction_bytes[expected_payload_end:])
        for signee in payload.signers:
            # extract the signature from the stream
            signature = bytearray.decode(buffer)

            # validate the signat
*/


function assertTxAreEqual(refence, other){
    expect(reference).toBeInstanceOf(Transaction);
    expect(other).toBeInstanceOf(Transaction);
    expect(reference.from_address()).toBe(other.from_address);
    expect(reference.transfers()).toBe(other.transfers());
    expect(reference.valid_from()).toBe(other.valid_from());
    expect(reference.valid_from()).toBe(other.valid_from());
    expect(reference.charge_rate()).toBe(other.charge_rate());
    expect(reference.charge_limit()).toBe(other.charge_limit());
    expect(reference.contract_digest()).toBe(other.contract_digest());
    expect(reference.contract_address()).toBe(other.contract_address());
    expect(reference.chain_code()).toBe(other.chain_code());
    expect(reference.action()).toBe(other.action());
    expect(reference.shard_mask()).toBe(other.shard_mask());
    expect(reference.data()).toBe(other.data());
    expect(reference.signers()).toBe(other.signers());
}
